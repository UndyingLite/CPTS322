{"ast":null,"code":"/**\r\n * Service for interacting with the Google Gemini API\r\n */\nconst geminiApiService = {\n  /**\r\n   * Get destination suggestions from Gemini\r\n   * \r\n   * @param {Object} preferences User's travel preferences\r\n   * @returns {Promise<Object>} Destination suggestions\r\n   */\n  getDestinationSuggestions: async preferences => {\n    try {\n      // API key - Replace with your actual Gemini API key\n      // You can get an API key from https://makersuite.google.com/app/apikey\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\n\n      // If no valid API key is provided, the service will fall back to mock data\n      if (apiKey === \"enterapikey\") {\n        console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\n        throw new Error(\"No valid API key\");\n      }\n\n      // Construct the prompt for Gemini\n      const prompt = `Create a detailed travel itinerary for a trip to ${preferences.destination} from ${preferences.startDate} to ${preferences.endDate}, with a budget of ${preferences.budget}. The user is interested in ${preferences.interests}.\n\n      The itinerary should include a list of activities for each day, including specific landmarks, restaurants, and other attractions. Please provide estimated costs for each activity.\n\n      Format your response ONLY as JSON with the following structure, and nothing else:\n      {\n        \"destination\": \"${preferences.destination}\",\n        \"startDate\": \"${preferences.startDate}\",\n        \"endDate\": \"${preferences.endDate}\",\n        \"budget\": \"${preferences.budget}\",\n        \"interests\": \"${preferences.interests}\",\n        \"itinerary\": [\n          {\n            \"day\": \"Day 1\",\n            \"activities\": [\n              {\n                \"description\": \"Activity description\",\n                \"estimatedCost\": \"Estimated cost in USD\"\n              }\n            ]\n          }\n        ]\n      }`;\n\n      // Make API call to Gemini\n      // TODO: The model 'gemini-2.0-pro-exp-02-05' is experimental. Consider switching to a stable model for production.\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-pro-exp-02-05:generateContent?key=${apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: prompt\n            }]\n          }],\n          generationConfig: {\n            temperature: 0.7,\n            maxOutputTokens: 2000\n          }\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error;\n        const errorData = await response.json();\n        throw new Error(((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'API request failed');\n      }\n      const data = await response.json();\n      console.log(\"Gemini API Response:\", data);\n\n      // Extract the content from Gemini's response\n      const responseText = data.candidates[0].content.parts[0].text;\n\n      // Log the raw response text for debugging\n      console.log(\"Raw Gemini API Response Text:\", responseText);\n\n      // Attempt to fix common JSON errors (missing commas)\n      let fixedResponseText = responseText.replace(/}\\s*{/g, '},{');\n\n      // Look for JSON in the response\n      const jsonMatch = fixedResponseText.match(/```json\\n([\\s\\S]*)\\n```/) || fixedResponseText.match(/({[\\s\\S]*})/);\n      let parsedData;\n      if (jsonMatch && jsonMatch[1]) {\n        parsedData = JSON.parse(jsonMatch[1]);\n      } else {\n        // Try parsing the entire response as JSON\n        try {\n          parsedData = JSON.parse(fixedResponseText);\n        } catch (error) {\n          throw new Error('Failed to parse JSON response from Gemini');\n        }\n      }\n      return parsedData;\n    } catch (error) {\n      console.error('Error in Gemini API service:', error);\n      throw error;\n    }\n  },\n  // ----------------------------------------------------\n  // GetChatResponse\n  // ----------------------------------------------------\n  /**\r\n   * Get a short travel-related chat response from Gemini\r\n   *\r\n   * @param {string} userMessage The user's text input\r\n   * @returns {Promise<string>} The AI-generated text\r\n   */\n  getChatResponse: async userMessage => {\n    try {\n      var _data$candidates, _data$candidates$, _data$candidates$$con, _data$candidates$$con2, _data$candidates$$con3;\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\n      if (apiKey === \"enterapikey\") {\n        console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\n        // Return a fallback response for testing since api key is having issues\n        return \"I don't have access to real-time data right now, but I can suggest checking out budget-friendly destinations like Southeast Asia or Eastern Europe. Both offer amazing cultural experiences at lower costs than Western Europe or North America.\";\n      }\n\n      // Use the same model as your other functions for consistency\n      const prompt = `The user wants a travel suggestion. They say: \"${userMessage}\"\n    \n    Please respond with at least one travel-related recommendation. \n    If relevant, include a budget-friendly tip or destination in your reply.\n    Format your answer as plain text.`;\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: prompt\n            }]\n          }],\n          generationConfig: {\n            temperature: 0.7,\n            maxOutputTokens: 500\n          }\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error2;\n        const errorData = await response.json();\n        throw new Error(((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || 'Chat request failed');\n      }\n      const data = await response.json();\n      console.log(\"Gemini Chat Response:\", data);\n\n      // Handle the Gemini response format\n      const responseText = (_data$candidates = data.candidates) === null || _data$candidates === void 0 ? void 0 : (_data$candidates$ = _data$candidates[0]) === null || _data$candidates$ === void 0 ? void 0 : (_data$candidates$$con = _data$candidates$.content) === null || _data$candidates$$con === void 0 ? void 0 : (_data$candidates$$con2 = _data$candidates$$con.parts) === null || _data$candidates$$con2 === void 0 ? void 0 : (_data$candidates$$con3 = _data$candidates$$con2[0]) === null || _data$candidates$$con3 === void 0 ? void 0 : _data$candidates$$con3.text;\n      console.log(\"Parsed responseText:\", responseText);\n      if (!responseText) {\n        throw new Error('No response text found from Gemini');\n      }\n      return responseText.trim();\n    } catch (error) {\n      console.error('Error in getChatResponse:', error);\n      throw error;\n    }\n  },\n  /**\r\n    * Get mock chat responses when API is unavailable\r\n    * \r\n    * @param {string} userMessage The user's text input\r\n    * @returns {string} A mock AI-generated response\r\n    */\n  getMockChatResponse: userMessage => {\n    const userMessageLower = userMessage.toLowerCase();\n    const greetingKeywords = [\"hey\", \"hello\", \"hi\"];\n    const gratitudeKeywords = [\"no, thank you\", \"thank you\", \"thanks\"];\n    const recommendationKeywords = [\"recommendation\", \"recommendations\", \"suggest\", \"suggestions\", \"trip\", \"travel\"];\n    const budgetKeywords = [\"cheap\", \"affordable\", \"budget\", \"inexpensive\"];\n    const luxuryKeywords = [\"luxury\", \"expensive\", \"premium\", \"high-end\"];\n    const helpKeywords = [\"help\", \"assistance\", \"advice\"];\n    if (greetingKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      return \"Hello! How can I help you plan your next adventure?\";\n    }\n    if (gratitudeKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      return \"You're welcome! Let me know if you need anything else.\";\n    }\n    if (helpKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      return \"I can help you with destination suggestions, itinerary planning, and budget advice. What are you looking for?\";\n    }\n    if (budgetKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      return \"For a budget-friendly trip, consider Southeast Asia or Eastern Europe. Check out Mexico or Central America for affordable travel options. Portugal and Spain can be surprisingly affordable, especially if you travel during the off-season.\";\n    }\n    if (luxuryKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      return \"For a luxurious getaway, consider the Maldives or Bora Bora. Explore the French Riviera or the Amalfi Coast for a high-end experience. Consider a safari in Africa for an unforgettable luxury adventure.\";\n    }\n    if (recommendationKeywords.some(keyword => userMessageLower.includes(keyword))) {\n      const responses = [\"Based on your interests, I'd recommend visiting Portugal. It's more affordable than many Western European destinations, with beautiful beaches, historic cities like Lisbon and Porto, and excellent food and wine!\", \"Thailand could be perfect for you! It offers amazing beaches, delicious food, and cultural experiences at a fraction of the cost of many destinations. Stay in budget guesthouses and eat street food to keep costs down.\", \"Consider Mexico City for your next trip! It has world-class museums, incredible food, and your money will go much further than in many US or European cities. The metro system makes getting around easy and affordable.\", \"Japan might seem expensive, but you can travel there on a budget by staying in capsule hotels or hostels, eating at conveyor belt sushi restaurants, and using a Japan Rail Pass for transportation.\", \"If you're looking for nature and adventure, consider Costa Rica. Visit during the green season (May-November) for lower prices, fewer tourists, and still plenty of sunshine between short rain showers.\"];\n      return responses[Math.floor(Math.random() * responses.length)];\n    }\n    return \"I'm sorry, I didn't understand your request. Can you please provide more information about what you're looking for?\";\n  },\n  /**\r\n   * Get destination suggestions based on user preferences\r\n   * \r\n   * @param {Object} preferences User's destination preferences\r\n   * @returns {Promise<Object>} Destination suggestions with details\r\n   */\n  getDestinationRecommendations: async preferences => {\n    try {\n      // API key - Replace with your actual Gemini API key\n      // You can get an API key from https://makersuite.google.com/app/apikey\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\n\n      // If no valid API key is provided, the service will fall back to mock data\n      if (apiKey === \"enterapikey\") {\n        console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\n        throw new Error(\"No valid API key\");\n      }\n\n      // Construct the prompt for Gemini\n      const prompt = `Suggest 3 travel destinations based on the following preferences:\n      - Budget: ${preferences.budget || 'Any'}\n      - Trip Duration: ${preferences.duration || 'Any'} days\n      - Interests: ${preferences.interests || 'General travel'}\n      - Climate: ${preferences.climate || 'Any'}\n      - Travel Style: ${preferences.travelStyle || 'Any'}\n      - Previously visited: ${preferences.previousDestinations || 'None'}\n\n      For each destination, provide:\n      1. Name of the destination\n      2. A brief description (2-3 sentences)\n      3. 3 key attractions\n      4. Best time to visit\n      5. Estimated daily budget in USD\n\n      Format your response ONLY as JSON with the following structure, and nothing else:\n      {\n        \"destinations\": [\n          {\n            \"name\": \"Destination Name\",\n            \"description\": \"Brief description of the destination\",\n            \"attractions\": [\"Attraction 1\", \"Attraction 2\", \"Attraction 3\"],\n            \"bestTimeToVisit\": \"Best time to visit\",\n            \"estimatedDailyBudget\": \"Estimated daily budget in USD\"\n          }\n        ]\n      }`;\n\n      // Make API call to Gemini\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-pro-exp-02-05:generateContent?key=${apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: prompt\n            }]\n          }],\n          generationConfig: {\n            temperature: 0.7,\n            maxOutputTokens: 2000\n          }\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error3;\n        const errorData = await response.json();\n        throw new Error(((_errorData$error3 = errorData.error) === null || _errorData$error3 === void 0 ? void 0 : _errorData$error3.message) || 'API request failed');\n      }\n      const data = await response.json();\n      console.log(\"Gemini API Response:\", data);\n\n      // Extract the content from Gemini's response\n      const responseText = data.candidates[0].content.parts[0].text;\n\n      // Log the raw response text for debugging\n      console.log(\"Raw Gemini API Response Text:\", responseText);\n\n      // Attempt to fix common JSON errors (missing commas)\n      let fixedResponseText = responseText.replace(/}\\s*{/g, '},{');\n\n      // Look for JSON in the response\n      const jsonMatch = fixedResponseText.match(/```json\\n([\\s\\S]*)\\n```/) || fixedResponseText.match(/({[\\s\\S]*})/);\n      let parsedData;\n      if (jsonMatch && jsonMatch[1]) {\n        parsedData = JSON.parse(jsonMatch[1]);\n      } else {\n        // Try parsing the entire response as JSON\n        try {\n          parsedData = JSON.parse(fixedResponseText);\n        } catch (error) {\n          throw new Error('Failed to parse JSON response from Gemini');\n        }\n      }\n      return parsedData;\n    } catch (error) {\n      console.error('Error in Gemini API service:', error);\n      throw error;\n    }\n  }\n};\nexport default geminiApiService;","map":{"version":3,"names":["geminiApiService","getDestinationSuggestions","preferences","apiKey","process","env","REACT_APP_GEMINI_API_KEY","console","warn","Error","prompt","destination","startDate","endDate","budget","interests","response","fetch","method","headers","body","JSON","stringify","contents","parts","text","generationConfig","temperature","maxOutputTokens","ok","_errorData$error","errorData","json","error","message","data","log","responseText","candidates","content","fixedResponseText","replace","jsonMatch","match","parsedData","parse","getChatResponse","userMessage","_data$candidates","_data$candidates$","_data$candidates$$con","_data$candidates$$con2","_data$candidates$$con3","_errorData$error2","trim","getMockChatResponse","userMessageLower","toLowerCase","greetingKeywords","gratitudeKeywords","recommendationKeywords","budgetKeywords","luxuryKeywords","helpKeywords","some","keyword","includes","responses","Math","floor","random","length","getDestinationRecommendations","duration","climate","travelStyle","previousDestinations","_errorData$error3"],"sources":["C:/Users/Phoni/OneDrive/Documents/GitHub/322/New folder/CPTS322/src/services/geminiApiService.js"],"sourcesContent":["/**\r\n * Service for interacting with the Google Gemini API\r\n */\r\nconst geminiApiService = {\r\n  /**\r\n   * Get destination suggestions from Gemini\r\n   * \r\n   * @param {Object} preferences User's travel preferences\r\n   * @returns {Promise<Object>} Destination suggestions\r\n   */\r\n  getDestinationSuggestions: async (preferences) => {\r\n    try {\r\n      // API key - Replace with your actual Gemini API key\r\n      // You can get an API key from https://makersuite.google.com/app/apikey\r\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\r\n      \r\n      // If no valid API key is provided, the service will fall back to mock data\r\n      if (apiKey === \"enterapikey\") {\r\n        console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\r\n        throw new Error(\"No valid API key\");\r\n      }\r\n      \r\n      // Construct the prompt for Gemini\r\n      const prompt = `Create a detailed travel itinerary for a trip to ${preferences.destination} from ${preferences.startDate} to ${preferences.endDate}, with a budget of ${preferences.budget}. The user is interested in ${preferences.interests}.\r\n\r\n      The itinerary should include a list of activities for each day, including specific landmarks, restaurants, and other attractions. Please provide estimated costs for each activity.\r\n\r\n      Format your response ONLY as JSON with the following structure, and nothing else:\r\n      {\r\n        \"destination\": \"${preferences.destination}\",\r\n        \"startDate\": \"${preferences.startDate}\",\r\n        \"endDate\": \"${preferences.endDate}\",\r\n        \"budget\": \"${preferences.budget}\",\r\n        \"interests\": \"${preferences.interests}\",\r\n        \"itinerary\": [\r\n          {\r\n            \"day\": \"Day 1\",\r\n            \"activities\": [\r\n              {\r\n                \"description\": \"Activity description\",\r\n                \"estimatedCost\": \"Estimated cost in USD\"\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      }`;\r\n      \r\n      // Make API call to Gemini\r\n      // TODO: The model 'gemini-2.0-pro-exp-02-05' is experimental. Consider switching to a stable model for production.\r\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-pro-exp-02-05:generateContent?key=${apiKey}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          contents: [\r\n            {\r\n              parts: [\r\n                {\r\n                  text: prompt\r\n                }\r\n              ]\r\n            }\r\n          ],\r\n          generationConfig: {\r\n            temperature: 0.7,\r\n            maxOutputTokens: 2000\r\n          }\r\n        })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error?.message || 'API request failed');\r\n      }\r\n      \r\n      const data = await response.json();\r\n      console.log(\"Gemini API Response:\", data);\r\n      \r\n      // Extract the content from Gemini's response\r\n      const responseText = data.candidates[0].content.parts[0].text;\r\n\r\n      // Log the raw response text for debugging\r\n      console.log(\"Raw Gemini API Response Text:\", responseText);\r\n\r\n      // Attempt to fix common JSON errors (missing commas)\r\n      let fixedResponseText = responseText.replace(\r\n        /}\\s*{/g,\r\n        '},{'\r\n      );\r\n\r\n      // Look for JSON in the response\r\n      const jsonMatch = fixedResponseText.match(/```json\\n([\\s\\S]*)\\n```/) || \r\n                         fixedResponseText.match(/({[\\s\\S]*})/);\r\n                         \r\n      let parsedData;\r\n      if (jsonMatch && jsonMatch[1]) {\r\n        parsedData = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        // Try parsing the entire response as JSON\r\n        try {\r\n          parsedData = JSON.parse(fixedResponseText);\r\n        } catch (error) {\r\n          throw new Error('Failed to parse JSON response from Gemini');\r\n        }\r\n      }\r\n      \r\n      return parsedData;\r\n    } catch (error) {\r\n      console.error('Error in Gemini API service:', error);\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  // ----------------------------------------------------\r\n  // GetChatResponse\r\n  // ----------------------------------------------------\r\n  /**\r\n   * Get a short travel-related chat response from Gemini\r\n   *\r\n   * @param {string} userMessage The user's text input\r\n   * @returns {Promise<string>} The AI-generated text\r\n   */\r\ngetChatResponse: async (userMessage) => {\r\n  try {\r\n    const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\r\n    if (apiKey === \"enterapikey\") {\r\n      console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\r\n      // Return a fallback response for testing since api key is having issues\r\n      return \"I don't have access to real-time data right now, but I can suggest checking out budget-friendly destinations like Southeast Asia or Eastern Europe. Both offer amazing cultural experiences at lower costs than Western Europe or North America.\";\r\n    }\r\n\r\n    // Use the same model as your other functions for consistency\r\n    const prompt = `The user wants a travel suggestion. They say: \"${userMessage}\"\r\n    \r\n    Please respond with at least one travel-related recommendation. \r\n    If relevant, include a budget-friendly tip or destination in your reply.\r\n    Format your answer as plain text.`;\r\n\r\n    const response = await fetch(\r\n      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`,\r\n      {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          contents: [\r\n            {\r\n              parts: [\r\n                {\r\n                  text: prompt\r\n                }\r\n              ]\r\n            }\r\n          ],\r\n          generationConfig: {\r\n            temperature: 0.7,\r\n            maxOutputTokens: 500\r\n          }\r\n        })\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      throw new Error(errorData.error?.message || 'Chat request failed');\r\n    }\r\n\r\n    const data = await response.json();\r\n    console.log(\"Gemini Chat Response:\", data);\r\n\r\n    // Handle the Gemini response format\r\n    const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;\r\n    console.log(\"Parsed responseText:\", responseText);\r\n    if (!responseText) {\r\n      throw new Error('No response text found from Gemini');\r\n    }\r\n\r\n    return responseText.trim();\r\n  } catch (error) {\r\n    console.error('Error in getChatResponse:', error);\r\n    throw error;\r\n  }\r\n},\r\n /**\r\n   * Get mock chat responses when API is unavailable\r\n   * \r\n   * @param {string} userMessage The user's text input\r\n   * @returns {string} A mock AI-generated response\r\n   */\r\n  getMockChatResponse: (userMessage) => {\r\n    const userMessageLower = userMessage.toLowerCase();\r\n\r\n    const greetingKeywords = [\"hey\", \"hello\", \"hi\"];\r\n    const gratitudeKeywords = [\"no, thank you\", \"thank you\", \"thanks\"];\r\n    const recommendationKeywords = [\"recommendation\", \"recommendations\", \"suggest\", \"suggestions\", \"trip\", \"travel\"];\r\n    const budgetKeywords = [\"cheap\", \"affordable\", \"budget\", \"inexpensive\"];\r\n    const luxuryKeywords = [\"luxury\", \"expensive\", \"premium\", \"high-end\"];\r\n    const helpKeywords = [\"help\", \"assistance\", \"advice\"];\r\n\r\n    if (greetingKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      return \"Hello! How can I help you plan your next adventure?\";\r\n    }\r\n\r\n    if (gratitudeKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      return \"You're welcome! Let me know if you need anything else.\";\r\n    }\r\n\r\n    if (helpKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      return \"I can help you with destination suggestions, itinerary planning, and budget advice. What are you looking for?\";\r\n    }\r\n\r\n    if (budgetKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      return \"For a budget-friendly trip, consider Southeast Asia or Eastern Europe. Check out Mexico or Central America for affordable travel options. Portugal and Spain can be surprisingly affordable, especially if you travel during the off-season.\";\r\n    }\r\n\r\n    if (luxuryKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      return \"For a luxurious getaway, consider the Maldives or Bora Bora. Explore the French Riviera or the Amalfi Coast for a high-end experience. Consider a safari in Africa for an unforgettable luxury adventure.\";\r\n    }\r\n\r\n    if (recommendationKeywords.some(keyword => userMessageLower.includes(keyword))) {\r\n      const responses = [\r\n        \"Based on your interests, I'd recommend visiting Portugal. It's more affordable than many Western European destinations, with beautiful beaches, historic cities like Lisbon and Porto, and excellent food and wine!\",\r\n        \"Thailand could be perfect for you! It offers amazing beaches, delicious food, and cultural experiences at a fraction of the cost of many destinations. Stay in budget guesthouses and eat street food to keep costs down.\",\r\n        \"Consider Mexico City for your next trip! It has world-class museums, incredible food, and your money will go much further than in many US or European cities. The metro system makes getting around easy and affordable.\",\r\n        \"Japan might seem expensive, but you can travel there on a budget by staying in capsule hotels or hostels, eating at conveyor belt sushi restaurants, and using a Japan Rail Pass for transportation.\",\r\n        \"If you're looking for nature and adventure, consider Costa Rica. Visit during the green season (May-November) for lower prices, fewer tourists, and still plenty of sunshine between short rain showers.\"\r\n      ];\r\n      return responses[Math.floor(Math.random() * responses.length)];\r\n    }\r\n\r\n    return \"I'm sorry, I didn't understand your request. Can you please provide more information about what you're looking for?\";\r\n  },\r\n\r\n  /**\r\n   * Get destination suggestions based on user preferences\r\n   * \r\n   * @param {Object} preferences User's destination preferences\r\n   * @returns {Promise<Object>} Destination suggestions with details\r\n   */\r\n  getDestinationRecommendations: async (preferences) => {\r\n    try {\r\n      // API key - Replace with your actual Gemini API key\r\n      // You can get an API key from https://makersuite.google.com/app/apikey\r\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY || \"enterapikey\";\r\n      \r\n      // If no valid API key is provided, the service will fall back to mock data\r\n      if (apiKey === \"enterapikey\") {\r\n        console.warn(\"No valid Gemini API key provided. Using mock data instead.\");\r\n        throw new Error(\"No valid API key\");\r\n      }\r\n      \r\n      // Construct the prompt for Gemini\r\n      const prompt = `Suggest 3 travel destinations based on the following preferences:\r\n      - Budget: ${preferences.budget || 'Any'}\r\n      - Trip Duration: ${preferences.duration || 'Any'} days\r\n      - Interests: ${preferences.interests || 'General travel'}\r\n      - Climate: ${preferences.climate || 'Any'}\r\n      - Travel Style: ${preferences.travelStyle || 'Any'}\r\n      - Previously visited: ${preferences.previousDestinations || 'None'}\r\n\r\n      For each destination, provide:\r\n      1. Name of the destination\r\n      2. A brief description (2-3 sentences)\r\n      3. 3 key attractions\r\n      4. Best time to visit\r\n      5. Estimated daily budget in USD\r\n\r\n      Format your response ONLY as JSON with the following structure, and nothing else:\r\n      {\r\n        \"destinations\": [\r\n          {\r\n            \"name\": \"Destination Name\",\r\n            \"description\": \"Brief description of the destination\",\r\n            \"attractions\": [\"Attraction 1\", \"Attraction 2\", \"Attraction 3\"],\r\n            \"bestTimeToVisit\": \"Best time to visit\",\r\n            \"estimatedDailyBudget\": \"Estimated daily budget in USD\"\r\n          }\r\n        ]\r\n      }`;\r\n      \r\n      // Make API call to Gemini\r\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-pro-exp-02-05:generateContent?key=${apiKey}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          contents: [\r\n            {\r\n              parts: [\r\n                {\r\n                  text: prompt\r\n                }\r\n              ]\r\n            }\r\n          ],\r\n          generationConfig: {\r\n            temperature: 0.7,\r\n            maxOutputTokens: 2000\r\n          }\r\n        })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error?.message || 'API request failed');\r\n      }\r\n      \r\n      const data = await response.json();\r\n      console.log(\"Gemini API Response:\", data);\r\n      \r\n      // Extract the content from Gemini's response\r\n      const responseText = data.candidates[0].content.parts[0].text;\r\n\r\n      // Log the raw response text for debugging\r\n      console.log(\"Raw Gemini API Response Text:\", responseText);\r\n\r\n      // Attempt to fix common JSON errors (missing commas)\r\n      let fixedResponseText = responseText.replace(\r\n        /}\\s*{/g,\r\n        '},{'\r\n      );\r\n\r\n      // Look for JSON in the response\r\n      const jsonMatch = fixedResponseText.match(/```json\\n([\\s\\S]*)\\n```/) || \r\n                         fixedResponseText.match(/({[\\s\\S]*})/);\r\n                         \r\n      let parsedData;\r\n      if (jsonMatch && jsonMatch[1]) {\r\n        parsedData = JSON.parse(jsonMatch[1]);\r\n      } else {\r\n        // Try parsing the entire response as JSON\r\n        try {\r\n          parsedData = JSON.parse(fixedResponseText);\r\n        } catch (error) {\r\n          throw new Error('Failed to parse JSON response from Gemini');\r\n        }\r\n      }\r\n      \r\n      return parsedData;\r\n    } catch (error) {\r\n      console.error('Error in Gemini API service:', error);\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\nexport default geminiApiService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}